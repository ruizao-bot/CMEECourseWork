Starting testing for Jiayi, Week3

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 4.56 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: .git, week1, week2, Feedback, week3

Found the following files in parent directory: .gitignore, README.md

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:

**********************************************************************
/week*/sandbox/
*~ __pycache__/
*.py[cod]
*.pyo
venv/
.env
*.log
*.sqlite3
*.user
*.suo
*.exe
*.obj
bin/
obj/
*.tmp
/week*/results/*
**********************************************************************

Found README in parent directory, named: README.md

Printing contents of README.md:

**********************************************************************
Name: CMEE Coursework Repository
Author: Chen Jiayi
E-mail: jc224@ic.ac.uk
Set-up time: 09/2024
Introduction: This is a course repository of bootcamp study in Silwood, with the code/scripts inside.

**********************************************************************

======================================================================
Looking for the weekly directories...

Found 3 weekly directories: week1, week2, week3

The Week3 directory will be tested 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Testing WEEK3...

Found the following directories: results, data, code

Found the following files: Readme.md

Checking for readme file in weekly directory...

Found README in parent directory, named: Readme.md

Printing contents of Readme.md:

**********************************************************************
---
editor_options: 
  markdown: 
    wrap: 72
---

# Week 3 R Codes

## Overview

This repository contains R scripts developed during Week 3 of the
course. The scripts demonstrate various programming concepts.

## Author

Chen Jiayi E-mail: [jc224\@ic.ac.uk](mailto:jc224@ic.ac.uk){.email}

## Language

R version 4.4.1 (2024-06-14)

## Structure

### Code list

**basic_io.R** - A simple script to illustrate R input-output.

control_flow.R - assigns a boolean value, generates a random number for
conditional checks

**control_flow.R** - initializes a boolean variable, generates a random
number, and demonstrates conditionals and loops to perform various print
operations based on specified conditions

**break.R** - initializes i to 0 and enters an infinite while loop that
prints i and increments it until i reaches 10, at which point the break
statement stops the loop.

**next.R** - iterates from 1 to 10, printing only the odd numbers by
using a condition to skip even numbers.

**boilerplate.R** - defines a function `MyFunction` in R, which takes
two arguments, prints each argument’s value and data type, and returns
both arguments as a vector.

**R_conditionals.R** - defines three functions in R to check integer
properties:

1.  **`is.even`**: Checks if a number is even or odd by testing
    divisibility by 2.

2.  **`is.power2`**: Checks if a number is a power of 2 by verifying if
    the base-2 logarithm is an integer.

3.  **`is.prime`**: Determines if a number is prime by checking
    divisibility only by integers between 2 and `n-1`.

Each function is tested with sample inputs to confirm their
functionality.

**TreeHeight.R** - calculates the height of a tree given the angle of
elevation (in degrees) and the distance from the tree's base.

**Vectorize1.R** - compares the execution time for summing all elements
in a 1000×1000 matrix `M` in two ways:

1.  **Using Nested Loops**: The custom `SumAllElements` function
    iterates over each matrix element with nested loops, summing them
    individually.

2.  **Using a Vectorized Function**: The built-in `sum()` function,
    which leverages R’s vectorized operations, efficiently sums all
    elements in the matrix.

**preallocate.R** - defines two functions to compare performance with
and without pre-allocation of vector memory

**apply1.R** - creates a 10×10 matrix `M` with random values from a
normal distribution and calculates row and column statistics

**apply2.R** - make a 10×10 matrix `M` is created with random values
from a normal distribution. The `apply` function is used to apply
`SomeOperation` to each row of the matrix (indicated by the `1`
argument). The result is a new matrix where each row has been processed
by `SomeOperation`, either scaled by 100 or left unchanged, depending on
the sum of the respective row.

**sample.R** - defines several functions for conducting a sampling
experiment from a given population, each with different approaches to
handle the results.

**browse.R** - simulates exponential growth over a specified number of
generations and plots the results.

**try.R** - defines a function to compute the mean of a sampled
population. The main part of the code generates a random population and
visualizes its distribution with a histogram.

**DataWrang.R** - loading, inspecting, transforming, and analyzing the
dataset.

**Girko.R** - generates and visualizes the eigenvalues of a random
matrix, overlaid with an ellipse to illustrate the distribution of the
eigenvalues.

**MyBars.R** - reads data from a text file and creates a plot using the
`ggplot2` package.

1.  import and inspect data

2.  create the ggplot object and add line ranges, annotations and aet
    axis labels and theme

3.  save the plot

**plotLin.R** - generates a dataset, performs linear regression, and
creates a plot to visualize the results along with a regression line.

### Data

EcolArchives-E089-51-D1.csv

PoundHillData.csv

PoundHillMetaData.csv

Results.txt

trees.csv

**********************************************************************

Results directory is empty - good! 

Found 22 code files: break.R, sample.R, Vectorize1.R, R_conditionals.R, apply1.R, basic_io.R, Girko.R, boilerplate.R, apply2.R, DataWrang.R, try.R, MyFirstJupyterNb.ipynb, control_flow.R, TreeHeight.R, TestR.py, TestR.R, plotLin.R, next.R, browse.R, Mybar.R, preallocate.R, Untitled.ipynb

======================================================================
Testing script/code files...

======================================================================
Inspecting script file break.R...

File contents are:

**********************************************************************
i = 0 #Initialize i
    while (i < Inf) {
        if (i == 10) {
            break 
        } else { # Break out of the while loop!  
            cat("i equals " , i , " \n")
            i <- i + 1 # Update i
    }
}
**********************************************************************

Testing break.R...

Output (only first 500 characters): 


**********************************************************************
i equals  0  
i equals  1  
i equals  2  
i equals  3  
i equals  4  
i equals  5  
i equals  6  
i equals  7  
i equals  8  
i equals  9  

**********************************************************************

Code ran without errors

Time consumed = 0.10994s

======================================================================
Inspecting script file sample.R...

File contents are:

**********************************************************************
########## Functions #########
## A function to take a sample of size n from a population "popn" and return its mean
myexperiment = function(popn,n){
    pop_sample = sample(popn,n,replace=FALSE)
    return(mean(pop_sample))
}

## Calculate means using a FORloop on a vector without preallocation:
loopy_sample1 = function(popn,n,num){
    result1 = vector()
    for(i in 1:num){
        result1 = c(result1, myexperiment(popn,n))
    }
    return(result1)
}

## To run "num" iterations of the experiment using a FOR loop on a vector with prellocation:
loopy_sample2 = function(popn,n,num){
    result2 = vector(,num) #Preallocate expected size
    for(i in 1:num){
        result2[i] = myexperiment(popn,n)
        
    }
    return(result2)
}

## To run "num" iterations of the experiment using a FOR loop on a list with preallocation:
loopy_sample3 = function(popn,n,num){
    result3 = vector("list", num) #Preallocate expected size
    for(i in 1:num){
        result3[[i]] = myexperiment(popn,n)
    }
    return(result3)
}

## To run "num" iterations of the experiment using vectorization with lapply:
lapply_sample = function(popn,n,num){
    result4 = lapply(1:num, function(i) myexperiment(popn,n))
    return(result4)

}

## To run "num" iterations of the experiment using vectorizetion with sapply:
sapply_sample = function(popn,n,num){
    result5 = sapply(1:num, function(i) myexperiment(popn,n))
    return(result5)
}

set.seed(12345)
popn <- rnorm(10000) # Generate the population
hist(popn)

n <- 100 # sample size for each experiment
num <- 10000# Number of times to rerun the experiment

print("Using loops without preallocation on a vector took:" )
print(system.time(loopy_sample1(popn, n, num)))

print("Using loops with preallocation on a vector took:" )
print(system.time(loopy_sample2(popn, n, num)))

print("Using loops with preallocation on a list took:" )
print(system.time(loopy_sample3(popn, n, num)))

print("Using the vectorized sapply function (on a list) took:" )
print(system.time(sapply_sample(popn, n, num)))

print("Using the vectorized lapply function (on a list) took:" )
print(system.time(lapply_sample(popn, n, num)))
**********************************************************************

Testing sample.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Using loops without preallocation on a vector took:"
   user  system elapsed 
  0.169   0.014   0.182 
[1] "Using loops with preallocation on a vector took:"
   user  system elapsed 
  0.113   0.000   0.113 
[1] "Using loops with preallocation on a list took:"
   user  system elapsed 
  0.121   0.000   0.121 
[1] "Using the vectorized sapply function (on a list) took:"
   user  system elapsed 
  0.115   0.000   0.114 
[1] "Using the vectorized lapply function (on a list) took:"
   user  syst
**********************************************************************

Code ran without errors

Time consumed = 0.81778s

======================================================================
Inspecting script file Vectorize1.R...

File contents are:

**********************************************************************
# Create a 1000x1000 matrix 'M' filled with random numbers between 0 and 1
M = matrix(runif(1000000), 1000, 1000)

# Function to sum all elements of a matrix using nested loops
SumAllElemtns = function(M){
    # Get the dimensions of the matrix (number of rows and columns)
    Dimensions = dim(M)
    # Initialize a variable 'Tot' to store the running total of the sum
    Tot = 0

    # Outer loop: iterate over each row of the matrix
    for(i in 1:Dimensions[1]){
        for(j in 1:Dimensions[2]){
            Tot = Tot + M[i,j]
        }
    }

    # Return the final sum
    return(Tot)
}

# Print the time taken to sum all matrix elements using the custom loop function
print("Using loops, the time taken is:")
print(system.time(SumAllElemtns(M)))

# Print the time taken to sum all matrix elements using the built-in vectorized 'sum' function
print("Using the in-built vectorized function, the time taken is:")
print(system.time(sum(M)))
**********************************************************************

Testing Vectorize1.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Using loops, the time taken is:"
   user  system elapsed 
  0.029   0.002   0.031 
[1] "Using the in-built vectorized function, the time taken is:"
   user  system elapsed 
  0.001   0.000   0.001 

**********************************************************************

Code ran without errors

Time consumed = 0.15420s

======================================================================
Inspecting script file R_conditionals.R...

File contents are:

**********************************************************************
# Checks if an integer is even
is.even <- function(n = 2) {
  # Check if 'n' is divisible by 2 (i.e., even)
  if (n %% 2 == 0) {
    return(paste(n,'is even!'))
  } else {
  return(paste(n,'is odd!'))
  }
}

# Test the is.even function with input 6
is.even(6)

# Checks if a number is a power of 2
is.power2 <- function(n = 2) {
  # Check if log base 2 of 'n' is an integer (i.e., n is a power of 2)
  if (log2(n) %% 1==0) {
    return(paste(n, 'is a power of 2!'))
  } else {
  return(paste(n,'is not a power of 2!'))
    }
}

# Test the is.power2 function with input 4
is.power2(4)

# Checks if a number is prime
is.prime <- function(n) {
  # Handle special cases for 0 and 1
  if (n==0) {
    return(paste(n,'is a zero!'))
  } else if (n==1) {
    return(paste(n,'is just a unit!'))
  }
  # Create a sequence of integers from 2 to n-1  
  ints <- 2:(n-1)
  
  if (all(n%%ints!=0)) {
    # Return message if 'n' is prime
    return(paste(n,'is a prime!'))
  } else {
  return(paste(n,'is a composite!'))
    }
}

# Test the is.prime function with input 3
is.prime(3)
**********************************************************************

Testing R_conditionals.R...

Output (only first 500 characters): 


**********************************************************************
[1] "6 is even!"
[1] "4 is a power of 2!"
[1] "3 is a prime!"

**********************************************************************

Code ran without errors

Time consumed = 0.09183s

======================================================================
Inspecting script file apply1.R...

File contents are:

**********************************************************************
##Build a random matrix
M = matrix(rnorm(100),10,10)

#Take the mean of each row
RowMeans = apply(M, 1, mean)
print(RowMeans) 

##Now the variance
RowVars = apply(M,1,var)
print(RowVars)

## By column
ColMeans = apply(M, 2, mean)
print(ColMeans)
**********************************************************************

Testing apply1.R...

Output (only first 500 characters): 


**********************************************************************
 [1] -0.20013212  0.58890256 -0.04171856  0.24298644  0.10200932 -0.07364644
 [7] -0.25583901 -0.20973740 -0.37274602 -0.30370196
 [1] 0.5980516 1.0291599 1.1225544 0.7864882 1.3855924 0.4157933 0.9630340
 [8] 0.4535589 0.8252092 1.0768227
 [1] -0.14687067 -0.12968517  0.18464054 -0.03723954  0.23361099  0.68180879
 [7] -0.16577554 -0.49070869 -0.72735988  0.07395594

**********************************************************************

Code ran without errors

Time consumed = 0.09057s

======================================================================
Inspecting script file basic_io.R...

File contents are:

**********************************************************************
# A simple script to illustrate R input-output.  
# Run line by line and check inputs outputs to understand what is happening  

MyData <- read.csv("../data/trees.csv", header = TRUE) # import with headers

write.csv(MyData, "../results/MyData.csv") #write it out as a new file

write.table(MyData[1,], file = "../results/MyData.csv",append=TRUE) # Append to it

write.csv(MyData, "../results/MyData.csv", row.names=TRUE) # write row names

write.table(MyData, "../results/MyData.csv", col.names=FALSE) # ignore column names
**********************************************************************

Testing basic_io.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Warning message:
In write.table(MyData[1, ], file = "../results/MyData.csv", append = TRUE) :
  appending column names to file

======================================================================
Inspecting script file Girko.R...

File contents are:

**********************************************************************
library(ggplot2)
# Function to build an ellipse based on specified horizontal and vertical radii
build_ellipse <- function(hradius, vradius){ # function that returns an ellipse
  npoints = 250
  a <- seq(0, 2 * pi, length = npoints + 1)
  x <- hradius * cos(a)
  y <- vradius * sin(a)  
  return(data.frame(x = x, y = y))
}

N <- 250 # Assign size of the matrix

# Generate a matrix of random numbers from a normal distribution
M <- matrix(rnorm(N * N), N, N) # Build the matrix

# Calculate the eigenvalues of the matrix
eigvals <- eigen(M)$values # Find the eigenvalues

# Create a dataframe to store the real and imaginary parts of the eigenvalues
eigDF <- data.frame("Real" = Re(eigvals), "Imaginary" = Im(eigvals)) # Build a dataframe

my_radius <- sqrt(N) # The radius of the circle is sqrt(N)

ellDF <- build_ellipse(my_radius, my_radius) # Dataframe to plot the ellipse


# Rename the columns of the ellipse dataframe for clarity
names(ellDF) <- c("Real", "Imaginary") # rename the columns


# plot the eigenvalues
p <- ggplot(eigDF, aes(x = Real, y = Imaginary))
p <- p +
  geom_point(shape = I(3)) +
  theme(legend.position = "none")

# now add the vertical and horizontal line
p <- p + geom_hline(aes(yintercept = 0))
p <- p + geom_vline(aes(xintercept = 0))

# finally, add the ellipse
p <- p + geom_polygon(data = ellDF, aes(x = Real, y = Imaginary, alpha = 1/20, fill = "red"))

# Open a PDF device to save the plot
pdf("../results/Girko.pdf", # Open blank pdf page using a relative path
    9, 8.3)
print(p)
graphics.off(); #you can also use dev.off() 
**********************************************************************

Testing Girko.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.55008s

======================================================================
Inspecting script file boilerplate.R...

File contents are:

**********************************************************************
# A boilerplate R script

# MyFunction: A simple function that prints the class (type) of two arguments and returns them as a vector.
# Args:
#   Arg1: The first argument, can be of any data type (e.g., numeric, character).
#   Arg2: The second argument, can be of any data type (e.g., numeric, character).
# Returns:
#   A vector containing Arg1 and Arg2.

MyFunction = function(Arg1, Arg2) {
    
    #Statements involving Arg1, Arg2
    print(paste("Argument", as.character(Arg1), "is a", class(Arg1)))
    print(paste("Argument", as.character(Arg2), "is a", class(Arg2)))

    return (c(Arg1, Arg2)) #this is optional, but very useful
}
MyFunction(1,2) #test the function
MyFunction("Riki","Tiki") #A different test
**********************************************************************

Testing boilerplate.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Argument 1 is a numeric"
[1] "Argument 2 is a numeric"
[1] 1 2
[1] "Argument Riki is a character"
[1] "Argument Tiki is a character"
[1] "Riki" "Tiki"

**********************************************************************

Code ran without errors

Time consumed = 0.10216s

======================================================================
Inspecting script file apply2.R...

File contents are:

**********************************************************************
# Define a function that modifies a numeric vector based on its sum
SomeOperation = function(v){#(What does this function do)
    if(sum(v)>0) { # note that sum(v) is a single (scalar value)
        return(v*100)
    } else {
        return(v)
    }
}

# Create a 10x10 matrix 'M' filled with random numbers from a normal distribution
M = matrix(rnorm(100),10,10)


# Apply the SomeOperation function to each row of the matrix 'M'
# The 'apply' function takes 'M', applies 'SomeOperation' to each row (M,1),
# and returns a vector of results
print(apply(M,1,SomeOperation))
**********************************************************************

Testing apply2.R...

Output (only first 500 characters): 


**********************************************************************
             [,1]        [,2]       [,3]        [,4]       [,5]        [,6]
 [1,] -169.839799  130.853813 -0.9010188 -0.28826292 -48.488284  0.65789476
 [2,]  -77.800084  164.227124 -0.2105061 -0.93389994  64.203681 -2.30224384
 [3,]  149.990261 -185.760941 -1.7775170 -1.21809441 223.797204  0.50800538
 [4,]   -3.623679  110.133205  0.2883479 -0.94694676   4.863418  0.09217229
 [5,]  -24.459884  -81.727065 -0.9144563  0.02024551  -8.389179  1.62287297
 [6,]  -34.133475    1.186674 -1.0436438  0.4
**********************************************************************

Code ran without errors

Time consumed = 0.10593s

======================================================================
Inspecting script file DataWrang.R...

File contents are:

**********************************************************************
################################################################
################## Wrangling the Pound Hill Dataset ############
################################################################

############# Load the dataset ###############
# header = false because the raw data don't have real headers
MyData <- as.matrix(read.csv("../data/PoundHillData.csv", header = FALSE))

# header = true because we do have metadata headers
MyMetaData <- read.csv("../data/PoundHillMetaData.csv", header = TRUE, sep = ";")

############# Inspect the dataset ###############
head(MyData)
dim(MyData)
str(MyData)
fix(MyData) #you can also do this
fix(MyMetaData)

############# Transpose ###############
# To get those species into columns and treatments into rows 
MyData <- t(MyData) 
head(MyData)
dim(MyData)

############# Replace species absences with zeros ###############
MyData[MyData == ""] = 0

############# Convert raw matrix to data frame ###############

TempData <- as.data.frame(MyData[-1,],stringsAsFactors = F) #stringsAsFactors = F is important!
colnames(TempData) <- MyData[1,] # assign column names from original data

############# Convert from wide to long format  ###############
require(reshape2) # load the reshape2 package

?melt #check out the melt function

MyWrangledData <- melt(TempData, id=c("Cultivation", "Block", "Plot", "Quadrat"), variable.name = "Species", value.name = "Count")

MyWrangledData[, "Cultivation"] <- as.factor(MyWrangledData[, "Cultivation"])
MyWrangledData[, "Block"] <- as.factor(MyWrangledData[, "Block"])
MyWrangledData[, "Plot"] <- as.factor(MyWrangledData[, "Plot"])
MyWrangledData[, "Quadrat"] <- as.factor(MyWrangledData[, "Quadrat"])
MyWrangledData[, "Count"] <- as.integer(MyWrangledData[, "Count"])

str(MyWrangledData)
head(MyWrangledData)
dim(MyWrangledData)

############# Exploring the data (extend the script below)  ###############
## Convert MyWrangledData to a tibble
MyWrangledData <- dplyr::as_tibble(MyWrangledData) 
MyWrangledData
# Another way
MyWrangledData <- as_tibble(MyWrangledData) 
class(MyWrangledData)

glimpse(MyWrangledData) #like str(), but nicer!

utils::View(MyWrangledData) #same as fix()
filter(MyWrangledData, Count>100) #like subset(), but nicer

slice(MyWrangledData, 10:15) # Look at a particular range of data rows

MyWrangledData %>%
    group_by(Species) %>%
        summarise(avg = mean(Count))

# Same function
aggregate(MyWrangledData$Count, list(MyWrangledData$Species), FUN=mean) 
**********************************************************************

Testing DataWrang.R...

Output (only first 500 characters): 


**********************************************************************
     V1                     V2        V3        V4        V5        V6       
[1,] "Cultivation"          "october" "october" "october" "october" "october"
[2,] "Block"                "a"       "a"       "a"       "a"       "a"      
[3,] "Plot"                 "1"       "1"       "1"       "1"       "1"      
[4,] "Quadrat"              "Q1"      "Q2"      "Q3"      "Q4"      "Q5"     
[5,] "Achillea millefolium" "4"       "8"       "3"       "20"      "6"      
[6,] "Agrostis gigantea"    ""   
**********************************************************************

Code ran without errors

Time consumed = 10.00863s

======================================================================
Inspecting script file try.R...

File contents are:

**********************************************************************
# Function to calculate the mean of a sampled population if conditions are met
doit <- function(x) {
     # Sample 'x' with replacement to create a new sample 'temp_x'
    temp_x <- sample(x, replace = TRUE)

    # Check if the number of unique values in the sample is greater than 30
    if(length(unique(temp_x)) > 30) {#only take mean if sample was sufficient
         # Calculate and print the mean of the sampled values
         print(paste("Mean of this sample was:", as.character(mean(temp_x))))
        } 
    else {
        # Stop execution and print an error message if too few unique values are present
        stop("Couldn't calculate mean: too few unique values!")
        }
    }

# Set a random seed for reproducibility of results
set.seed(1345) # again, to get the same result for illustration

# Generate a population of 50 random values from a normal distribution
popn <- rnorm(50)

# Create a histogram of the generated population to visualize its distribution
hist(popn)
**********************************************************************

Testing try.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.15377s

======================================================================
Inspecting script file MyFirstJupyterNb.ipynb...

File contents are:

**********************************************************************
{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a826082e",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b084a5d7-33be-4d0b-aac0-512372aa3800",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "id": "2e6c5b7e-7fe2-4119-99cc-aa80c5a1a018",
   "metadata": {},
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}

**********************************************************************

Testing MyFirstJupyterNb.ipynb...

======================================================================
Inspecting script file control_flow.R...

File contents are:

**********************************************************************
# Assigning TRUE to variable 'a'
a = TRUE

# Checking if 'a' is TRUE
if (a == TRUE){
    # Print statement if 'a' is TRUE
    print("a is TRUE")
} else{
    # Print statement if 'a' is FALSE
    print("a is FLASE")
}

# Generating a random number between 0 and 1
z = runif(1)

# Check if the random number 'z' is less than or equal to 0.5
if (z <= 0.5) {
    # Print statement if 'z' is less than or equal to 0.5
    print("Less than a half")}

# Loop from 1 to 10
for(i in 1:10){
    j = i*i
    print(paste(i,"sqaured is", j))
}

# Loop through a list of bird species
for(species in c('Heliodoxa rubinoides', 
                 'Boissonneaua jardini', 
                 'Sula nebouxii')) {
      print(paste('The species is', species))
}

# Defining a vector with three string elements
v1 = c("a", "bc", "def")
for (i in v1){
    print(i)
}

i = 0
# A while loop that continues as long as 'i' is less than 10
while(i < 10){
    i = i+1
    print(i^2)
}
**********************************************************************

Testing control_flow.R...

Output (only first 500 characters): 


**********************************************************************
[1] "a is TRUE"
[1] "Less than a half"
[1] "1 sqaured is 1"
[1] "2 sqaured is 4"
[1] "3 sqaured is 9"
[1] "4 sqaured is 16"
[1] "5 sqaured is 25"
[1] "6 sqaured is 36"
[1] "7 sqaured is 49"
[1] "8 sqaured is 64"
[1] "9 sqaured is 81"
[1] "10 sqaured is 100"
[1] "The species is Heliodoxa rubinoides"
[1] "The species is Boissonneaua jardini"
[1] "The species is Sula nebouxii"
[1] "a"
[1] "bc"
[1] "def"
[1] 1
[1] 4
[1] 9
[1] 16
[1] 25
[1] 36
[1] 49
[1] 64
[1] 81
[1] 100

**********************************************************************

Code ran without errors

Time consumed = 0.12211s

======================================================================
Inspecting script file TreeHeight.R...

File contents are:

**********************************************************************
# This function calculates heights of trees given distance of each tree 
# from its base and angle to its top, using  the trigonometric formula 
#
# height = distance * tan(radians)
#
# ARGUMENTS
# degrees:   The angle of elevation of tree
# distance:  The distance from base of tree (e.g., meters)
#
# OUTPUT
# The heights of the tree, same units as "distance"

TreeHeight <- function(degrees, distance) {
    radians <- degrees * pi / 180
    height <- distance * tan(radians)
    print(paste("Tree height is:", height))
  
    return (height)
}

TreeHeight(37, 40)
**********************************************************************

Testing TreeHeight.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Tree height is: 30.1421620041118"
[1] 30.14216

**********************************************************************

Code ran without errors

Time consumed = 0.09039s

======================================================================
Inspecting script file TestR.py...

File contents are:

**********************************************************************
import subprocess
p = subprocess.Popen("Rscript --verbose TestR.R > ../results/TestR.Rout 2> ../results/TestR_errFile.Rout", shell=True).wait()
**********************************************************************

Testing TestR.py...

TestR.py is a Python script file;

checking for docstrings...

No functions, but no script-level docstring either
Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.10737s

======================================================================
Inspecting script file TestR.R...

File contents are:

**********************************************************************
print("Hello, this is R!")
**********************************************************************

Testing TestR.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Hello, this is R!"

**********************************************************************

Code ran without errors

Time consumed = 0.09780s

======================================================================
Inspecting script file plotLin.R...

File contents are:

**********************************************************************
# Generate a sequence of numbers from 0 to 100 with an increment of 0.1
x <- seq(0, 100, by = 0.1)

# Create a response variable 'y' as a linear function of 'x' plus some random noise
y <- -4. + 0.25 * x +
  rnorm(length(x), mean = 0., sd = 2.5)

# and put them in a dataframe
my_data <- data.frame(x = x, y = y)

# perform a linear regression
my_lm <- summary(lm(y ~ x, data = my_data))

# plot the data
p <-  ggplot(my_data, aes(x = x, y = y,
                          colour = abs(my_lm$residual))
             ) +
  geom_point() +
  scale_colour_gradient(low = "black", high = "red") +
  theme(legend.position = "none") +
  scale_x_continuous(
    expression(alpha^2 * pi / beta * sqrt(Theta)))

# add the regression line
p <- p + geom_abline(
  intercept = my_lm$coefficients[1][1],
  slope = my_lm$coefficients[2][1],
  colour = "red")
  
# throw some math on the plot
p <- p + geom_text(aes(x = 60, y = 0,
                       label = "sqrt(alpha) * 2* pi"), 
                       parse = TRUE, size = 6, 
                       colour = "blue")

p


# Save the plot as a PDF file with specified dimensions
pdf("../results/MyLinReg.pdf", # Open blank pdf page using a relative path
    9, 8.3)
print(p)
graphics.off(); #you can also use dev.off() 
**********************************************************************

Testing plotLin.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Error in ggplot(my_data, aes(x = x, y = y, colour = abs(my_lm$residual))) : 
  could not find function "ggplot"
Execution halted

======================================================================
Inspecting script file next.R...

File contents are:

**********************************************************************
for (i in 1:10) {
  # Check if 'i' is even (remainder is 0 when divided by 2)
  if ((i %% 2) == 0) # check if the number is odd
    next # pass to next iteration of loop 
  print(i)
}
**********************************************************************

Testing next.R...

Output (only first 500 characters): 


**********************************************************************
[1] 1
[1] 3
[1] 5
[1] 7
[1] 9

**********************************************************************

Code ran without errors

Time consumed = 0.10524s

======================================================================
Inspecting script file browse.R...

File contents are:

**********************************************************************
# Function to simulate exponential growth over a specified number of generations
Exponential <- function(N0 = 1, r = 1, generations = 10) {
  # Runs a simulation of exponential growth
  # Returns a vector of length generations
  
  N <- rep(NA, generations)    # Creates a vector of NA
  
  N[1] <- N0
  # Loop through each generation from 2 to the specified number of generations
  for (t in 2:generations) {
    # Calculate the population size for the current generation based on the previous generation
    N[t] <- N[t-1] * exp(r)
    browser() # Allows for debugging; pauses execution to inspect variables
  }
  return (N)
}

# Plot the results of the exponential growth simulation
plot(Exponential(), type="l", main="Exponential growth")
**********************************************************************

Testing browse.R...

Output (only first 500 characters): 


**********************************************************************
Called from: Exponential()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()

**********************************************************************

Code ran without errors

Time consumed = 0.12197s

======================================================================
Inspecting script file Mybar.R...

File contents are:

**********************************************************************
# Read data from a text file into a dataframe 'a'
a <- read.table("../data/Results.txt", header = TRUE)
# Display the first few rows of the dataframe for inspection
head(a)

# Initialize a new column 'ymin' with zeros for each row in the dataframe
a$ymin = rep(0,dim(a)[1])

# Start creating a ggplot object with the data from dataframe 'a'
p = ggplot(a)

# Add the first line range (geom_linerange) to the plot
p = p + geom_linerange(data = a, aes(
                        x = x,
                        ymin = ymin,
                        ymax = y1,
                        size = (0.5)
                        ),
                    colour = "#E69F00",
                    alpha = 1/2, show.legend = FALSE)


# Add the second line range to the plot
p <- p + geom_linerange(data = a, aes(
                          x = x,
                          ymin = ymin,
                          ymax = y2,
                          size = (0.5)
                          ),
                        colour = "#56B4E9",
                        alpha = 1/2, show.legend = FALSE)

# Print the third linerange:
p <- p + geom_linerange(data = a, aes(
                          x = x,
                          ymin = ymin,
                          ymax = y3,
                          size = (0.5)
                          ),
                        colour = "#D55E00",
                        alpha = 1/2, show.legend = FALSE)

# Annotate the plot with labels:
p <- p + geom_text(data = a, aes(x = x, y = -500, label = Label))

# now set the axis labels, remove the legend, and prepare for bw printing
p <- p + scale_x_continuous("My x axis",
                            breaks = seq(3, 5, by = 0.05)) + 
                            scale_y_continuous("My y axis") + 
                            theme_bw() + 
                            theme(legend.position = "none") 

# Print the final plot to a PDF file
pdf("../results/MyBars.pdf", # Open blank pdf page using a relative path
    9, 8.3)
print(p)
graphics.off(); #you can also use dev.off() 
**********************************************************************

Testing Mybar.R...

Output (only first 500 characters): 


**********************************************************************
         x   y1   y2 y3 Label
1 3.515424 4320 4320  0  <NA>
2 3.533984 2160 2160  0  <NA>
3 3.557647 4320 4320  0  <NA>
4 3.569953 4320 4320  0  <NA>
5 3.578984 8640 8640  0  <NA>
6 3.585665 2160 2160  0  <NA>

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Error in ggplot(a) : could not find function "ggplot"
Execution halted

======================================================================
Inspecting script file preallocate.R...

File contents are:

**********************************************************************
# Function that demonstrates the effect of not preallocating a vector
NoPreallocFun = function(x){
    a = vector() #empty vecotr
    for(i in 1:x) {
        a = c(a,i) #concatenate
        print(a) # Print the current state of the vector
        print(object.size(a)) # Print the memory size of the vector
    }
}

# Measure the time taken to execute the NoPreallocFun with input 10
system.time(NoPreallocFun(10))

PreallocFun = function(x){
    a = rep(NA,x) #pre-allocated vector
    for(i in 1:x){
        a[i] = i
        print(a)
        print(object.size(a))
    }
}

# Measure the time taken to execute the PreallocFun with input 10
system.time(PreallocFun(10))
**********************************************************************

Testing preallocate.R...

Output (only first 500 characters): 


**********************************************************************
[1] 1
56 bytes
[1] 1 2
56 bytes
[1] 1 2 3
64 bytes
[1] 1 2 3 4
64 bytes
[1] 1 2 3 4 5
80 bytes
[1] 1 2 3 4 5 6
80 bytes
[1] 1 2 3 4 5 6 7
80 bytes
[1] 1 2 3 4 5 6 7 8
80 bytes
[1] 1 2 3 4 5 6 7 8 9
96 bytes
 [1]  1  2  3  4  5  6  7  8  9 10
96 bytes
   user  system elapsed 
  0.009   0.001   0.011 
 [1]  1 NA NA NA NA NA NA NA NA NA
96 bytes
 [1]  1  2 NA NA NA NA NA NA NA NA
96 bytes
 [1]  1  2  3 NA NA NA NA NA NA NA
96 bytes
 [1]  1  2  3  4 NA NA NA NA NA NA
96 bytes
 [1]  1  2  3  4  5 NA N
**********************************************************************

Code ran without errors

Time consumed = 0.12942s

======================================================================
Inspecting script file Untitled.ipynb...

File contents are:

**********************************************************************
{
 "cells": [],
 "metadata": {},
 "nbformat": 4,
 "nbformat_minor": 5
}

**********************************************************************

Testing Untitled.ipynb...

======================================================================
======================================================================
Finished running scripts

Ran into 3 errors

======================================================================
======================================================================

FINISHED LOGGING

